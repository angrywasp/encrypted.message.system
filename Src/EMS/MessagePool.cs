using System.Collections.Generic;
using System.Text;
using AngryWasp.Helpers;
using AngryWasp.Net;
using EMS.Commands.P2P;
using System.Linq;
using System.Collections.Concurrent;
using System.Diagnostics;
using System;
using System.IO;

namespace EMS
{
    public static class MessagePool
    {
        private static ConcurrentDictionary<HashKey16, Message> messages = new ConcurrentDictionary<HashKey16, Message>();
        private static HashSet<HashKey16> outgoingMessages = new HashSet<HashKey16>();

        public static ConcurrentDictionary<HashKey16, Message> Messages => messages;
        public static HashSet<HashKey16> OutgoingMessages => outgoingMessages;

        public static bool Send(string address, string message, uint expiration, out HashKey16 messageKey)
        {
            messageKey = HashKey16.Empty;

            if (message.Length > (16 * 1024))
            {
                Log.WriteError("Message exceeds the 16kb limit");
                return false;
            }

            if (expiration < GlobalConfig.MIN_MESSAGE_EXPIRATION)
            {
                Log.WriteError($"Message expiration is less than the minimum {GlobalConfig.MIN_MESSAGE_EXPIRATION}");
                return false;
            }

            byte[] encryptionResult, signature, addressXor;
            ReadProof readProof = ReadProof.Create();
    
            // Construct and encrypt the message
            //  - read proof nonce
            //  - plain text message
            byte[] msg = readProof.Nonce.Concat(Encoding.ASCII.GetBytes(message)).ToArray();

            if (!KeyRing.EncryptMessage(msg, address, out encryptionResult, out signature, out addressXor))
                return false;

            // Construct the message that will be PoW hashed
            //  - nonce (empty uint until hashed)
            //  - expiration time
            //  - encrypted message signature length
            //  - encrypted message length
            //  - obfuscated sender/receiver address
            //  - read proof hash
            //  - encrypted message signature
            //  - encrypted message
            byte[] finalMessage = new List<byte>(new byte[] {0, 0, 0, 0})
                .Join(BitShifter.ToByte(expiration))
                .Join(BitShifter.ToByte((ushort)signature.Length))
                .Join(BitShifter.ToByte((ushort)encryptionResult.Length))
                .Join(addressXor)
                .Join(readProof.Hash)
                .Join(signature)
                .Join(encryptionResult).ToArray();

            // Pow hash the message
            // We generate a new starting nonce and inser that into the first 4 bytes of the 
            // message, which we initialized with 0. We hash each nonce and increment until
            // we find a nonce that passes the difficulty target test
            uint x = MathHelper.Random.GenerateRandomSeed();
            ulong difficulty = expiration * GlobalConfig.DIFF_MULTIPLIER;
            HashKey32 messageHash = HashKey32.Empty;
            Stopwatch sw = new Stopwatch();
            sw.Start();
            while(true)
            {
                Buffer.BlockCopy(BitShifter.ToByte(x), 0, finalMessage, 0, 4);
                messageHash = SlowHash.Hash(finalMessage).ToByte();
                if (PowValidator.Validate(messageHash, difficulty))
                    break;

                ++x;
            }

            sw.Stop();

            Log.WriteConsole($"Hashed in {sw.ElapsedMilliseconds / 1000.0} seconds, {messageHash}");

            uint timestamp = (uint)DateTimeHelper.TimestampNow();

            // Finally we construct the final message
            //  - message hash (generated by the PoW hashing)
            //  - timestamp of the message
            // We append the creation timestamp after the PoW portion so 
            // we aren't burning the FTL window hashing the message
            finalMessage = messageHash.ToList()
                .Join(BitShifter.ToByte(timestamp))
                .Join(finalMessage).ToArray();

            messageKey = HashKey16.Make(finalMessage);

            // Add a new message to the pool.
            if (!messages.TryAdd(messageKey, new Message
            {
                Key = messageKey,
                Hash = messageHash,
                Data = finalMessage,
                Timestamp = timestamp,
                Expiration = expiration,
                Address = address,
                DecryptedMessage = message
            }))
            { 
                Log.WriteWarning("Could not add message to the encrypted message pool. Message not sent"); 
                return false;
            }

            //cross reference to the message pool for messages we have sent
            outgoingMessages.Add(messageKey);

            byte[] req = ShareMessage.GenerateRequest(true, finalMessage).ToArray();

            ConnectionManager.ForEach(Direction.Incoming | Direction.Outgoing, (c) =>
            {
                c.Write(req);
            });

            return true;
        }

        public static bool MarkMessageRead(HashKey16 key)
        {
            Message msg = null;

            if (!messages.TryGetValue(key, out msg))
            {
                Log.WriteWarning($"Message with key {key} does not exist. Cannot mark as read");
                return false;
            }

            if (!msg.IsDecrypted)
            {
                Log.WriteWarning($"Message with key {key} is not decrypted. Cannot mark as read");
                return false;
            }

            if (msg.ReadProof == null)
            {
                Log.WriteWarning($"Message with key {key} does not have a valid read proof. Cannot mark as read");
                return false;
            }

            //mark the message read internally for anyone requesting the message pool later
            msg.ReadProof.IsRead = true;

            byte[] message = key.Concat(msg.ReadProof.Nonce).ToArray();
            byte[] req = ShareMessageRead.GenerateRequest(true, message).ToArray();

            ConnectionManager.ForEach(Direction.Incoming | Direction.Outgoing, (c) =>
            {
                c.Write(req);
            });

            return true;
        }
    }
}